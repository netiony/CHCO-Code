---
title: "ATTEMPT scRNA analysis on Hyak (mixed model)"
author: "Ye Ji Choi"
date: "`r lubridate::today()`"
format: 
  html:
    toc: true
    toc-depth: 5
    toc-location: left
    code-fold: true
    embed-resources: true
---

```{r libraries, message = F, warning=F}
#| include: false
library(future)
library(future.apply)
library(tidyverse)
library(colorspace)
library(patchwork)
library(ggdendro)
library(cowplot)
library(ggpubr)
library(rstatix)
library(arsenal)
library(Biobase)
library(msigdbr)
library(kableExtra)
library(knitr)
library(REDCapR)
library(data.table)
library(emmeans)
library(NMF)
library(pheatmap)
library(UpSetR)
library(enrichR)
library(WriteXLS)
library(SAVER)
library(readxl)
library(limma)
library(edgeR)
library(BiocGenerics)
library(GSEABase)
library(slingshot)
library(SingleCellExperiment)
library(MAST)
library(muscat)
library(scater)
library(Seurat)
library(jsonlite)
library(dplyr)
library(glmmTMB)
library(reshape2)
library(broom.mixed) 
library(foreach)
library(doParallel)
library(nebula)
library(Matrix)
library(scran)
library(DirichletReg)
```

```{r include = F}
reticulate::use_python("/mmfs1/gscratch/scrubbed/yejichoi/mypy/bin/python", required = T)
reticulate::repl_python()
reticulate::py_config()
# set up Kopah connection
## Load boto3 and pandas
boto3 <- reticulate::import("boto3")
pd <- reticulate::import("pandas")

## Create an S3 client
keys <- fromJSON("/mmfs1/home/yejichoi/keys.json")
session <- boto3$session$Session(
  aws_access_key_id = keys$MY_ACCESS_KEY,
  aws_secret_access_key = keys$MY_SECRET_KEY
)

## Create an S3 client with the session
s3 <- session$client("s3", endpoint_url = "https://s3.kopah.uw.edu")
```

```{r echo = F, include=F}
# read ATTEMPT Seurat file
temp_file <- tempfile(fileext = ".RDS")
s3$download_file("scrna", "Kidney transcriptomics/Single cell RNA seq/PB_attempt_harmony_rpca_RM_kpmpV1labelled_Sept2024.RDS", temp_file)
attempt_so <- readRDS(temp_file)

# calculate cell library size for offset

# Identify mitochondrial genes
mito_genes <- grep("^MT-", rownames(attempt_so), value = TRUE)

# Calculate the percentage of mitochondrial transcripts per cell
attempt_so[["percent.mt"]] <- PercentageFeatureSet(attempt_so, pattern = "^MT-")
hist(attempt_so$percent.mt)
# FeaturePlot(attempt_so, reduction = "umap.harmony", features = "percent.mt", cols = c("lightgray", "blue"), raster = F)
# DimPlot(attempt_so, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = F, alpha = 0.2, label = T)
# DimPlot(attempt_so, reduction = "umap.harmony", group.by = "celltype", raster = F, alpha = 0.2, label = T)

# Identify ribosomal genes
ribo_genes <- c(
  "RPL22", "RPL11", "RPS8", "RPL5", "RPS27", "RPS7", "RPS27A", "RPL31", "RPL37A", "RPL32", "RPL15", "RPL14", "RPL29",
  "RPL24", "RPL22L1", "RPL35A", "RPL9", "RPL34", "RPS3A", "RPL37", "RPS23", "RPS14", "RPS18", "RPS10", "RPL10A", 
  "RPS20", "RPL7", "RPL30", "RPL8", "RPS6", "RPL35", "RPL12", "RPL7A", "RPS24", "RPLP2", "RPL27A", "RPS13", "RPS3",
  "RPS25", "RPS26", "RPL41", "RPL6", "RPLP0", "RPL21", "RPS29", "RPL4", "RPLP1", "RPS17", "RPS2", "RPS15A", "RPL13",
  "RPL26", "RPL23A", "RPL23", "RPL19", "RPL27", "RPL38", "RPL17", "RPS15", "RPL36", "RPS28", "RPL18A", "RPS16", 
  "RPS19", "RPL18", "RPL13A", "RPS11", "RPS9", "RPL28", "RPS5", "RPS21", "RPL3", "RPS4X", "RPL36A", "RPL39", 
  "RPL10", "RPS4Y1"
) # grep("^RPL|^RPS", rownames(attempt_so), value = TRUE) captures some none ribosomal genes
attempt_so[["percent.ribo"]] <- PercentageFeatureSet(attempt_so, features = ribo_genes)
hist(attempt_so$percent.ribo)

# attempt_so <- subset(attempt_so, subset = percent.mt < 50) # keep as 50%, it's how it's done with KPMP
FeaturePlot(attempt_so, reduction = "umap.harmony", features = "percent.mt", cols = c("lightgray", "blue"), raster = F)
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = F, alpha = 0.2, label = T)
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "celltype", raster = F, alpha = 0.2, label = T)

attempt_so <- subset(attempt_so, features = setdiff(rownames(attempt_so), mito_genes)) # remove MT- genes
attempt_so <- subset(attempt_so, features = setdiff(rownames(attempt_so), ribo_genes)) # remove ribosomal genes

expr_matrix <- as.matrix(GetAssayData(attempt_so, layer = "data"))
# Calculate the proportion of cells expressing each gene
num_cells_per_gene <- rowSums(expr_matrix > 0)  # Count nonzero cells per gene
total_cells <- ncol(expr_matrix)  # Total number of cells
gene_proportion <- num_cells_per_gene / total_cells  # Fraction of cells expressing each gene
length(gene_proportion) # 30625
# Keep genes expressed in at least 5% of cells
genes_to_keep <- names(gene_proportion[gene_proportion  >= 0.05])
length(genes_to_keep) # 8672 ( ~ 28.3% remaining)

remove(expr_matrix)
attempt_so <- subset(attempt_so, features = genes_to_keep)

# # calculate cell library size for offset in NEBULA
# counts_layer <- round(GetAssayData(attempt_so, layer = "counts"))
# library_size <- Matrix::colSums(counts_layer)
attempt_so$library_size <- library_size
# View(attempt_so@meta.data)

# TMM offset
# dge <- DGEList(counts = counts_layer)
# dge <- calcNormFactors(dge, method = "TMM")
# tmm_offset <- (dge$samples$lib.size) * (dge$samples$norm.factors)
attempt_so$tmm_offset <- tmm_offset

# Pooled offset
# sce <- SingleCellExperiment(assays = list(counts = counts_layer))
# sce <- computeSumFactors(sce)
# # View size factors
# sizeFactors(sce)
# # Calculate offset â†’ (size factors)
pooled_offset <- (sizeFactors(sce))
attempt_so$pooled_offset <- pooled_offset
```

```{r echo = F}
# read ATTEMPT clinical data file
temp_file <- tempfile(fileext = ".RDS")
s3$download_file("harmonized.dataset", "attempt_clinical_data.RDS", temp_file)
dat <- readRDS(temp_file)

attempt_so_meta <- attempt_so@meta.data %>%
  mutate(subject_id = Subject.ID,
         visit = case_when(Visit == "BL" ~ "PRE", 
                           Visit == "4M" ~ "POST"))
attempt_so_meta <- left_join(attempt_so_meta, dat, by = c("subject_id", "visit"))
rownames(attempt_so_meta) <- attempt_so_meta$barcode
attempt_so <- AddMetaData(attempt_so, attempt_so_meta)
options(future.globals.maxSize = 3000 * 1024^3)
```

# All cell types

```{r echo = F}
attempt_so$visit <- factor(attempt_so$visit, levels = c("PRE", "POST"))
attempt_so$treatment <- factor(attempt_so$treatment, levels = c("Placebo", "Dapagliflozin 5mg"),
                                  labels = c("Placebo", "Dapagliflozin"))
```

```{r echo = F}
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "visit", raster = F, alpha = 0.2)
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "treatment", raster = F, alpha = 0.2)
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "celltype", raster = F, alpha = 0.2, label = T)
DimPlot(attempt_so, reduction = "umap.harmony", group.by = "KPMP_celltype", raster = F, alpha = 0.2, label = T)
```

#### Proportions (Non weighted)

```{r echo = F}
attempt_so$celltype_general <- case_when(
  grepl("PT-", attempt_so$celltype) ~ "PT",
  grepl("TAL-", attempt_so$celltype) ~ "TAL",
  attempt_so$celltype %in% c("MON", "MAC", "T", "B", "NKT/NKC") ~ "Immune",
  attempt_so$celltype %in% c("PC-1", "PC-2", "tPC-IC") ~ "PC",
  attempt_so$celltype %in% c("IC-A", "IC-B") ~ "IC",
  attempt_so$celltype %in% c("EC-PTC", "EC-GC", "EC-AEA", "EC-LYM") ~ "EC",
  attempt_so$celltype %in% c("FIB", "VSMC/P") ~ "FIB/VSMC/P",
  TRUE ~ "Other - ATL, CNT, DCT, DTL, MC, PEC, POD, lowQ")

attempt_meta <- attempt_so@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_meta$visit_treatment <- factor(attempt_meta$visit_treatment, 
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_meta$celltype <- factor(attempt_meta$celltype,
                                level = c("PT-1", "PT-2", "PT-3", "PT-4", "PT-5", 
                                          "TAL-1", "TAL-2", "TAL-3", "TAL_highUMI", 
                                          "DTL-1", "DTL-2", 
                                          "CNT", "PC-1", "PC-2", 
                                          "tPC-IC", "IC-A", "IC-A_lowQuality", "IC-B", 
                                          "ATL", 
                                          "POD", "PEC", 
                                          "DCT",
                                          "MC", 
                                          "EC-PTC", "EC-GC", "EC-AEA", "EC-LYM", 
                                          "VSMC/P", "FIB", 
                                          "MAC", "MON", "NKT/NKC", "T", "B"))


attempt_meta$celltype_general <- factor(attempt_meta$celltype_general,
                                levels = c("PT", 
                                           "TAL", 
                                           "PC", 
                                           "IC", 
                                           "EC", 
                                           "FIB/VSMC/P", 
                                           "Immune", 
                                           "Other - ATL, CNT, DCT, DTL, MC, PEC, POD, lowQ"))

# Check counts
table(attempt_so$celltype_general)

attempt_meta %>% 
  filter(!grepl("_", celltype)) %>%
  ggplot(aes(celltype, fill = visit_treatment)) + 
  geom_bar(stat = "count") +
  theme_classic() +
  labs(x = NULL,
       y = "Cell count",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("Cell type distribution") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/attempt_cellcounts_plot.jpeg") 

attempt_meta %>%
  filter(!grepl("_", celltype)) %>%
  ggplot(aes(celltype, fill = visit_treatment)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 15)
s3$upload_file(temp_file, "attempt", "Figures/attempt_cellcounts_proportions_plot.jpeg") 

attempt_meta %>% 
  ggplot(aes(celltype_general, fill = visit_treatment)) + 
  geom_bar(stat = "count") +
  theme_classic() +
  labs(x = NULL,
       y = "Cell count",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("General cell type distribution") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file)
s3$upload_file(temp_file, "attempt", "Figures/attempt_general_cellcounts_plot.jpeg") 

attempt_meta %>%
  ggplot(aes(celltype_general, fill = visit_treatment)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/attempt_general_cellcounts_proportions_plot.jpeg") 

celltype_counts <- attempt_meta %>%
  filter(!grepl("Other", as.character(celltype_general))) %>%
  group_by(celltype_general) %>%
  summarise(n = n()) %>%
  ungroup()

attempt_meta %>% 
  filter(!grepl("Other", celltype_general)) %>%
  ggplot(aes(celltype_general, fill = visit_treatment)) + 
  geom_bar(stat = "count") +
  geom_text(data = celltype_counts, aes(x = celltype_general, y = n, label = n), 
            vjust = -0.5, size = 4, inherit.aes = FALSE) +
  theme_classic() +
  labs(x = NULL,
       y = "Cell count",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold")) +
  ggtitle("General cell type distribution") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file)
s3$upload_file(temp_file, "attempt", "Figures/attempt_general_cellcounts_plot_clean.jpeg") 

attempt_meta %>%
  filter(!grepl("Other", celltype_general)) %>%
  ggplot(aes(celltype_general, fill = visit_treatment)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#fbc4ab", "#f4978e",
                               "#aaae8e", "#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file)
s3$upload_file(temp_file, "attempt", "Figures/attempt_general_cellcounts_proportions_plot_clean.jpeg") 

attempt_meta %>%
  filter(KPMP_celltype %in% c("PT-S1/S2", "PT-S3", "aPT")) %>%
  ggplot(aes(KPMP_celltype, fill = visit_treatment)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("PRE Placebo" = "#fbc4ab", "POST Placebo" ="#f4978e",
                               "PRE Dapagliflozin"= "#aaae8e", "POST Dapagliflozin" ="#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file)
s3$upload_file(temp_file, "attempt", "Figures/attempt_kpmp_pt_proportions_plot.jpeg") 

attempt_meta$kpmp_tal <- case_when(grepl("TAL", attempt_so$KPMP_celltype) ~ attempt_so$KPMP_celltype)
attempt_meta$kpmp_tal <- factor(attempt_meta$kpmp_tal,
                                levels = c("aTAL", "dTAL", "C-TAL-1", "C-TAL-2"))
attempt_meta %>%
  filter(!is.na(attempt_meta$kpmp_tal)) %>%
  ggplot(aes(kpmp_tal, fill = visit_treatment)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("PRE Placebo" = "#fbc4ab", "POST Placebo" ="#f4978e",
                               "PRE Dapagliflozin"= "#aaae8e", "POST Dapagliflozin" ="#828e82"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file)
s3$upload_file(temp_file, "attempt", "Figures/attempt_kpmp_tal_proportions_plot.jpeg") 
```


```{r echo = F}
# test on proportions using Drichlet
pt_props <- attempt_meta %>%
  filter(celltype_general %in% c("PT")) %>%
  group_by(subject_id, treatment, visit, celltype) %>%
  summarise(n = n(), .groups = "drop") %>%
  group_by(subject_id) %>%
  mutate(prop = n / sum(n)) %>%
  dplyr::select(subject_id, treatment, celltype, visit, prop) %>%
  pivot_wider(names_from = celltype, values_from = prop, values_fill = 0)

pt_props <- pt_props %>%
  mutate(prop_sum = rowSums(across(c("PT-1", "PT-2", "PT-3", "PT-4", "PT-5"))))
# Convert to DirichletReg format
pt_props$Y <- DR_data(pt_props_pre[,4:8])
pt_props_drichlet <- DirichReg(Y ~ treatment * visit, data = pt_props)
summary(pt_props_drichlet)

```



```{r echo = F}
attempt_so <- FindVariableFeatures(attempt_so, selection.method = "vst", nfeatures = 2000)
hvgs <- VariableFeatures(attempt_so)

#Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg <- subset(attempt_so, features = hvgs)
```

# Descriptive

```{r echo = F}
unique_attempt_meta <- attempt_meta %>%
  dplyr::select(Subject.ID, Visit, age, Sex, treatment_arm , visit_treatment, diabetes_duration) %>%
  dplyr::summarise(across(where(negate(is.numeric)), ~ ifelse(all(is.na(.x)), NA_character_, last(na.omit(.x)))),
                   across(where(is.numeric), ~ ifelse(all(is.na(.x)), NA_real_, mean(.x, na.rm = TRUE))),
                   .by = c(Subject.ID, Visit))
summary(arsenal::tableby(visit_treatment ~ age + Sex + diabetes_duration + treatment_arm + Visit, data = unique_attempt_meta), test = F, digits = 1)

```


```{r echo = F}
# Functions for running mixed models

# Model 1: Nested visit, zero inflation (~50% convergence)
fit_model <- function(gene, sc_dat) {
  # Subset data (use data.table for speed)
  sc_dat_sub <- sc_dat[sc_dat$Gene == gene, ]

  # Fit the model with glmmTMB, handling errors
  model <- tryCatch({
    glmmTMB(Count ~ Treatment * Visit + (1 | Subject/Visit),
            data = sc_dat_sub, family = nbinom2, ziformula = ~1)
  }, error = function(e) return(NULL))

  if (is.null(model)) return(NULL)

  # Extract fixed effect results
  model_summary <- summary(model)

  dt <- as.data.table(model_summary$coefficients$cond)
  dt[, Gene := gene]
  setnames(dt, c("Std. Error", "Pr(>|z|)"), c("StdError", "PValue"))
  dt <- dt[, .(Gene, Variable = rownames(model_summary$coefficients$cond), Estimate, StdError, PValue)]

  # Extract emmeans (count part)
  emmeans_dt_count <- as.data.table(emmeans(model, specs = c("Treatment", "Visit")))
  emmeans_dt_count[, Gene := gene]
  # Return a named list where the gene is the top-level name
  return(list(model = dt, emmeans = emmeans_dt_count))
}

# Model 2: Removed nested visit, zero inflation (~10% convergence for cell types with high cell count)
fit_model_2 <- function(gene, sc_dat) {
  # Subset data (use data.table for speed)
  sc_dat_sub <- sc_dat[sc_dat$Gene == gene, ]

  # Fit the model with glmmTMB, handling errors
  model <- tryCatch({
    glmmTMB(Count ~ Treatment * Visit + (1 | Subject),
            data = sc_dat_sub, family = nbinom2, ziformula = ~1)
  }, error = function(e) return(NULL))

  if (is.null(model)) return(NULL)

  # Extract fixed effect results
  model_summary <- summary(model)

  dt <- as.data.table(model_summary$coefficients$cond)
  dt[, Gene := gene]
  setnames(dt, c("Std. Error", "Pr(>|z|)"), c("StdError", "PValue"))
  dt <- dt[, .(Gene, Variable = rownames(model_summary$coefficients$cond), Estimate, StdError, PValue)]

  # Extract emmeans (count part)
  emmeans_dt_count <- as.data.table(emmeans(model, specs = c("Treatment", "Visit")))
  emmeans_dt_count[, Gene := gene]
  # Return a named list where the gene is the top-level name
  return(list(model = dt, emmeans = emmeans_dt_count))
}

# Model 3: Nested visit, removed zero inflation
fit_model_3 <- function(gene, sc_dat) {
  # Subset data (use data.table for speed)
  sc_dat_sub <- sc_dat[sc_dat$Gene == gene, ]

  # Fit the model with glmmTMB, handling errors
  model <- tryCatch({
    glmmTMB(Count ~ Treatment * Visit + (1 | Subject/Visit),
            data = sc_dat_sub, family = nbinom2)
  }, error = function(e) return(NULL))

  if (is.null(model)) return(NULL)

  # Extract fixed effect results
  model_summary <- summary(model)

  dt <- as.data.table(model_summary$coefficients$cond)
  dt[, Gene := gene]
  setnames(dt, c("Std. Error", "Pr(>|z|)"), c("StdError", "PValue"))
  dt <- dt[, .(Gene, Variable = rownames(model_summary$coefficients$cond), Estimate, StdError, PValue)]

  # Extract emmeans
  emmeans_dt <- as.data.table(emmeans(model, ~ Treatment * Visit))
  emmeans_dt[, Gene := gene]

  # Return a named list where the gene is the top-level name
  return(list(model = dt, emmeans = emmeans_dt))
}

# Model 4: Removed nested visit, removed zero inflation
fit_model_4 <- function(gene, sc_dat) {
  # Subset data (use data.table for speed)
  sc_dat_sub <- sc_dat[sc_dat$Gene == gene, ]

  # Fit the model with glmmTMB, handling errors
  model <- tryCatch({
    glmmTMB(Count ~ Treatment * Visit + (1 | Subject),
            data = sc_dat_sub, family = nbinom2)
  }, error = function(e) return(NULL))

  if (is.null(model)) return(NULL)

  # Extract fixed effect results
  model_summary <- summary(model)

  dt <- as.data.table(model_summary$coefficients$cond)
  dt[, Gene := gene]
  setnames(dt, c("Std. Error", "Pr(>|z|)"), c("StdError", "PValue"))
  dt <- dt[, .(Gene, Variable = rownames(model_summary$coefficients$cond), Estimate, StdError, PValue)]

  # Extract emmeans
  emmeans_dt <- as.data.table(emmeans(model, ~ Treatment * Visit))
  emmeans_dt[, Gene := gene]

  # Return a named list where the gene is the top-level name
  return(list(model = dt, emmeans = emmeans_dt))
}
```

# PT
```{r echo = F}
attempt_so$celltype_pt <- ifelse(grepl("PT-", attempt_so$celltype),
                                 "PT", as.character(attempt_so$celltype))
attempt_so_pt <- subset(attempt_so, celltype_pt == "PT" & celltype != "PT_lowQuality")
```

```{r echo = F}
attempt_so_pt <- FindVariableFeatures(attempt_so_pt, selection.method = "vst", nfeatures = 2000)
hvgs_pt <- VariableFeatures(attempt_so_pt)

#Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_pt <- subset(attempt_so_pt, features = hvgs_pt)
```

#### Proportions
```{r echo = F, eval = F}
attempt_pt_meta <- attempt_so_hvg_pt@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))

attempt_pt_meta$celltype <- factor(attempt_pt_meta$celltype, levels = c("PT-1", "PT-2", "PT-3", "PT-4", "PT-5"))
attempt_pt_meta$visit_treatment <- factor(attempt_pt_meta$visit_treatment,
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_pt_meta %>%
  filter(celltype != "PT_lowQuality") %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pt_visit_proportions_plot.jpeg")

attempt_pt_meta %>%
  filter(celltype != "PT_lowQuality") %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pt_treatment_proportions_plot.jpeg")


attempt_pt_meta %>%
  filter(celltype != "PT_lowQuality") %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pt_treatment_visit_proportions_plot.jpeg")

attempt_meta %>%
  filter(KPMP_celltype %in% c("PT-S1/S2", "PT-S3", "aPT")) %>%
  ggplot(aes(visit, fill = KPMP_celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pt_visit_proportions_plot_kpmp.jpeg")

attempt_meta %>%
  filter(KPMP_celltype %in% c("PT-S1/S2", "PT-S3", "aPT")) %>%
  ggplot(aes(visit_treatment, fill = KPMP_celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pt_visit_treatment_proportions_plot_kpmp.jpeg")
```

#### Mixed model (hurdle, no nested random effect)

##### nebula
```{r echo = F, eval = F}
# nebula built-in testing
# data(sample_data)
# pred = model.matrix(~X1+X2+cc,data=sample_data$pred)
# re = nebula(count=sample_data$count,id=sample_data$sid,pred=pred, , output_re = T, covariance = T)
```
###### ML with rounded counts
```{r echo = F, eval = F}
# PT
counts_hvg_pt <- round(GetAssayData(attempt_so_hvg_pt, layer = "counts")) # load counts and round

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_pt)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pt_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_pt[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pt, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_pt_results_list <- Filter(Negate(is.null), nebula_pt_results_list)  # remove NULLs first
names(nebula_pt_results_list) <- sapply(nebula_pt_results_list, function(x) x$gene)  # set names
nebula_pt_results_list <- lapply(nebula_pt_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pt_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pt_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/nebula/pt_attempt_hvg_nebula_res.rds')
```

###### REML with rounded counts

```{r echo = F, eval = F}
# REML
counts_hvg_pt <- round(GetAssayData(attempt_so_hvg_pt, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pt)
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pt_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pt[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pt, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pt_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pt_results_list_reml) <- sapply(nebula_pt_results_list_reml, function(x) x$gene)  # set names
nebula_pt_results_list_reml <- lapply(nebula_pt_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_pt_results_list_reml <- Filter(Negate(is.null), nebula_pt_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pt_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pt_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/nebula/pt_attempt_hvg_nebula_res_reml.rds')
```

###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_pt <- round(GetAssayData(attempt_so_hvg_pt, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pt)

# meta_hvg_pt <- attempt_so_hvg_pt@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pt)
# data_g_hvg_pt = group_cell(count=counts_hvg_pt, id=meta_hvg_pt$subject, pred=pred)
# offset_hvg_pt = Matrix::colSums(data_g_hvg_pt$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()


nebula_pt_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pt[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pt, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pt_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pt_results_list_reml_offset) <- sapply(nebula_pt_results_list_reml_offset, function(x) x$gene)  # set names
nebula_pt_results_list_reml_offset <- lapply(nebula_pt_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_pt_results_list_reml_offset <- Filter(Negate(is.null), nebula_pt_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pt_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pt_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/nebula/pt_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_pt <- round(GetAssayData(attempt_so_hvg_pt, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pt)

# meta_hvg_pt <- attempt_so_hvg_pt@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pt)
# data_g_hvg_pt = group_cell(count=counts_hvg_pt, id=meta_hvg_pt$subject, pred=pred)
# offset_hvg_pt = Matrix::colSums(data_g_hvg_pt$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()


nebula_pt_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pt[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pt, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pt_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pt_results_list_reml_tmm) <- sapply(nebula_pt_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_pt_results_list_reml_tmm <- lapply(nebula_pt_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_pt_results_list_reml_tmm <- Filter(Negate(is.null), nebula_pt_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pt_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pt_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/nebula/pt_attempt_hvg_nebula_res_reml_tmm.rds')
```

###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_pt <- round(GetAssayData(attempt_so_hvg_pt, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pt)

# meta_hvg_pt <- attempt_so_hvg_pt@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pt)
# data_g_hvg_pt = group_cell(count=counts_hvg_pt, id=meta_hvg_pt$subject, pred=pred)
# offset_hvg_pt = Matrix::colSums(data_g_hvg_pt$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()


nebula_pt_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pt[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pt, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pt_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pt_results_list_reml_pooled) <- sapply(nebula_pt_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_pt_results_list_reml_pooled <- lapply(nebula_pt_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_pt_results_list_reml_pooled <- Filter(Negate(is.null), nebula_pt_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pt_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pt_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/nebula/pt_attempt_hvg_nebula_res_reml_pooled.rds')
```

##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_pt, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_pt, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_pt@meta.data$treatment,
                      Subject = attempt_so_hvg_pt@meta.data$subject_id,
                      Visit = attempt_so_hvg_pt@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```

```{r echo = F, eval = F}
# plan(multisession, workers = 120)
# 
# trouble shooting... (~ 50% non-convergence)
sampled_data <- sc_data 
%>% filter(Gene%in%hvgs_pt[101:200])
genes <- unique(sampled_data$Gene)

# ## trying no nested visit
fit_glmmTMB_zinb <- function(gene) {
  gene_data <- sampled_data %>% filter(Gene == gene)
  model <- glmmTMB(Count ~ Treatment * Visit + (1 | Subject),
                   data = gene_data, family = nbinom2, ziformula = ~1)
  if (!is.null(model)) {
    results <- summary(model)$coefficients$cond %>% as.data.frame() %>%
      rownames_to_column("Parameter") %>%
      mutate(Gene = gene)  # Add Gene column
    return(results)
  } else {
    return(data.frame(Gene = gene, Parameter = NA, Estimate = NA, Std.Error = NA, z.value = NA, Pr = NA))
  }
}
results_list_zinb <- map(genes, fit_glmmTMB_zinb)
final_results_zinb <- bind_rows(results_list_zinb)
nonconverged_genes_zinb <- (final_results_zinb %>%
  group_by(Gene) %>%
  filter(all(is.na(`z value`))))$Gene
(length(unique(nonconverged_genes_zinb))/length(genes))*100
# 20.15%

# ## trying nested visit
fit_glmmTMB_zinb_nested <- function(gene) {
  gene_data <- sampled_data %>% filter(Gene == gene)
  model <- glmmTMB(Count ~ Treatment * Visit + (1 | Subject/Visit),
                   data = gene_data, family = nbinom2, ziformula = ~1)
  if (!is.null(model)) {
    results <- summary(model)$coefficients$cond %>% as.data.frame() %>%
      rownames_to_column("Parameter") %>%
      mutate(Gene = gene)  # Add Gene column
    return(results)
  } else {
    return(data.frame(Gene = gene, Parameter = NA, Estimate = NA, Std.Error = NA, z.value = NA, Pr = NA))
  }
}
results_list_zinb_nested <- map(genes, fit_glmmTMB_zinb_nested)
final_results_zinb_nested <- bind_rows(results_list_zinb_nested)
nonconverged_genes_zinb_nested <- (final_results_zinb_nested %>%
  group_by(Gene) %>%
  filter(all(is.na(`z value`))))$Gene
(length(unique(nonconverged_genes_zinb_nested))/length(genes))*100
# 0.65%
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_pt, ceiling(seq_along(hvgs_pt) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)
# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)

# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```


```{r echo = F, eval = F}
# # Model 1
# # Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/1/pt_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/1/pt_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/2/pt_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PT/2/pt_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PT/3/pt_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PT/3/pt_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# Model 4
# Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PT/4/pt_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PT/4/pt_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)

* # of genes up/down
* upset plots of overlap in cell types
* pathways (IPA and GSEA - GO/KEGG/one that Long used from Broad)
* pseudotime (call with Kelly)
* BOLD MRI stuff in the PPT so that we show everything in one slide

# TAL

```{r echo = F}
attempt_so$celltype_tal <- ifelse(grepl("TAL-", attempt_so$celltype),
                                 "TAL", as.character(attempt_so$celltype))
attempt_so_tal <- subset(attempt_so, celltype_tal == "TAL" & celltype != "TAL_highUMI")
```

```{r echo = F}
attempt_so_tal <- FindVariableFeatures(attempt_so_tal, selection.method = "vst", nfeatures = 2000)
hvgs_tal <- VariableFeatures(attempt_so_tal)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_tal <- subset(attempt_so_tal, features = hvgs_tal)
```

#### Proportions
```{r echo = F, eval = F}
attempt_tal_meta <- attempt_so_hvg_tal@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_tal_meta$celltype <- factor(attempt_tal_meta$celltype, levels = c("TAL-1", "TAL-2", "TAL-3"))
attempt_tal_meta$visit_treatment <- factor(attempt_tal_meta$visit_treatment,
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_tal_meta %>%
  filter(celltype != "TAL_highUMI") %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_treatment_visit_proportions_plot.jpeg")

attempt_tal_meta %>%
  filter(celltype != "tal_lowQuality") %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_treatment_proportions_plot.jpeg")

attempt_tal_meta %>%
  filter(celltype != "tal_lowQuality") %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_treatment_visit_proportions_plot.jpeg")

attempt_meta %>%
  filter(grepl("TAL", KPMP_celltype)) %>%
  ggplot(aes(visit, fill = kpmp_tal)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_visit_proportions_plot_kpmp.jpeg")

attempt_meta %>%
  filter(grepl("TAL", KPMP_celltype)) %>%
  ggplot(aes(treatment, fill = kpmp_tal)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_treatment_proportions_plot_kpmp.jpeg")

attempt_meta %>%
  filter(grepl("TAL", KPMP_celltype)) %>%
  ggplot(aes(visit_treatment, fill = kpmp_tal)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_tal_visit_treatment_proportions_plot_kpmp.jpeg")
```

#### Mixed model (hurdle, nested random effect)
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_tal <- round(GetAssayData(attempt_so_hvg_tal, layer = "counts")) # load counts and round
# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_tal)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_tal_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_tal[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_tal, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, ncore = 1, output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_tal_results_list <- Filter(Negate(is.null), nebula_tal_results_list)  # remove NULLs first
names(nebula_tal_results_list) <- sapply(nebula_tal_results_list, function(x) x$gene)  # set names
nebula_tal_results_list <- lapply(nebula_tal_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_tal_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_tal_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/nebula/tal_attempt_hvg_nebula_res.rds')
```
###### REML with rounded counts

```{r echo = F, eval = F}
# REML
counts_hvg_tal <- round(GetAssayData(attempt_so_hvg_tal, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_tal)
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_tal_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_tal[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_tal, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_tal_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_tal_results_list_reml) <- sapply(nebula_tal_results_list_reml, function(x) x$gene)  # set names
nebula_tal_results_list_reml <- lapply(nebula_tal_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_tal_results_list_reml <- Filter(Negate(is.null), nebula_tal_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_tal_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_tal_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/nebula/tal_attempt_hvg_nebula_res_reml.rds')
```
###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_tal <- round(GetAssayData(attempt_so_hvg_tal, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_tal)

# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)
# offset_hvg_tal = Matrix::colSums(data_g_hvg_tal$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_tal_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_tal[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_tal, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_tal_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_tal_results_list_reml_offset) <- sapply(nebula_tal_results_list_reml_offset, function(x) x$gene)  # set names
nebula_tal_results_list_reml_offset <- lapply(nebula_tal_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_tal_results_list_reml_offset <- Filter(Negate(is.null), nebula_tal_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_tal_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_tal_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/nebula/tal_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_tal <- round(GetAssayData(attempt_so_hvg_tal, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_tal)

# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)
# offset_hvg_tal = Matrix::colSums(data_g_hvg_tal$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_tal_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_tal[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_tal, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_tal_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_tal_results_list_reml_tmm) <- sapply(nebula_tal_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_tal_results_list_reml_tmm <- lapply(nebula_tal_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_tal_results_list_reml_tmm <- Filter(Negate(is.null), nebula_tal_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_tal_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_tal_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/nebula/tal_attempt_hvg_nebula_res_reml_tmm.rds')
```

###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_tal <- round(GetAssayData(attempt_so_hvg_tal, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_tal)

# meta_hvg_tal <- attempt_so_hvg_tal@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_tal)
# data_g_hvg_tal = group_cell(count=counts_hvg_tal, id=meta_hvg_tal$subject, pred=pred)
# offset_hvg_tal = Matrix::colSums(data_g_hvg_tal$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_tal_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_tal[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_tal, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_tal_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_tal_results_list_reml_pooled) <- sapply(nebula_tal_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_tal_results_list_reml_pooled <- lapply(nebula_tal_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_tal_results_list_reml_pooled <- Filter(Negate(is.null), nebula_tal_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_tal_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_tal_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/nebula/tal_attempt_hvg_nebula_res_reml_pooled.rds')
```


##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_tal, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_tal, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_tal@meta.data$treatment,
                      Subject = attempt_so_hvg_tal@meta.data$subject_id,
                      Visit = attempt_so_hvg_tal@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_tal, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_tal, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_tal@meta.data$treatment,
                      Subject = attempt_so_hvg_tal@meta.data$subject_id,
                      Visit = attempt_so_hvg_tal@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_tal, ceiling(seq_along(hvgs_tal) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```

```{r echo = F, eval = F}
# Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/1/tal_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/1/tal_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/2/tal_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'TAL/2/tal_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'TAL/3/tal_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'TAL/3/tal_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'TAL/4/tal_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'TAL/4/tal_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)

# Immune Cells

```{r echo = F}
# immune cells: MAC, MON, T, B, NKT/NKC
attempt_so$celltype_immune <- ifelse(attempt_so$celltype %in% c("MON", "MAC", "T", "B", "NKT/NKC"),
                                     "Immune", as.character(attempt_so$celltype))
attempt_so_immune <- subset(attempt_so, celltype_immune == "Immune")
```

```{r echo = F}
attempt_so_immune <- FindVariableFeatures(attempt_so_immune, selection.method = "vst", nfeatures = 2000)
hvgs_immune <- VariableFeatures(attempt_so_immune)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_immune <- subset(attempt_so_immune, features = hvgs_immune)
```


#### Proportions
```{r echo = F, eval = F}
attempt_immune_meta <- attempt_so_hvg_immune@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_immune_meta$celltype <- factor(attempt_immune_meta$celltype, levels = c("MON", "MAC", "T", "B", "NKT/NKC"))
attempt_immune_meta$visit_treatment <- factor(attempt_immune_meta$visit_treatment,
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_immune_meta %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_immune_treatment_visit_proportions_plot.jpeg")

attempt_immune_meta %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_immune_treatment_proportions_plot.jpeg")

attempt_immune_meta %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261", "#e76f51"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_immune_treatment_visit_proportions_plot.jpeg")
```

#### Mixed model (hurdle, nested random effect)
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_immune <- round(GetAssayData(attempt_so_hvg_immune, layer = "counts")) # load counts and round
# meta_hvg_immune <- attempt_so_hvg_immune@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_immune)
# data_g_hvg_immune = group_cell(count=counts_hvg_immune, id=meta_hvg_immune$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_immune)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_immune_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_immune[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_immune, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, , output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_immune_results_list <- Filter(Negate(is.null), nebula_immune_results_list)  # remove NULLs first
names(nebula_immune_results_list) <- sapply(nebula_immune_results_list, function(x) x$gene)  # set names
nebula_immune_results_list <- lapply(nebula_immune_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_immune_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_immune_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/nebula/immune_attempt_hvg_nebula_res.rds')
```

###### REML with rounded counts

```{r echo = F, eval = F}
# REML
counts_hvg_immune <- round(GetAssayData(attempt_so_hvg_immune, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_immune)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_immune_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_immune[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_immune, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_immune_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_immune_results_list_reml) <- sapply(nebula_immune_results_list_reml, function(x) x$gene)  # set names
nebula_immune_results_list_reml <- lapply(nebula_immune_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_immune_results_list_reml <- Filter(Negate(is.null), nebula_immune_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_immune_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_immune_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/nebula/immune_attempt_hvg_nebula_res_reml.rds')
```

###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_immune <- round(GetAssayData(attempt_so_hvg_immune, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_immune)

# meta_hvg_immune <- attempt_so_hvg_immune@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_immune)
# data_g_hvg_immune = group_cell(count=counts_hvg_immune, id=meta_hvg_immune$subject, pred=pred)
# offset_hvg_immune = Matrix::colSums(data_g_hvg_immune$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_immune_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_immune[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_immune, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_immune_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_immune_results_list_reml_offset) <- sapply(nebula_immune_results_list_reml_offset, function(x) x$gene)  # set names
nebula_immune_results_list_reml_offset <- lapply(nebula_immune_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_immune_results_list_reml_offset <- Filter(Negate(is.null), nebula_immune_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_immune_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_immune_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/nebula/immune_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_immune <- round(GetAssayData(attempt_so_hvg_immune, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_immune)

# meta_hvg_immune <- attempt_so_hvg_immune@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_immune)
# data_g_hvg_immune = group_cell(count=counts_hvg_immune, id=meta_hvg_immune$subject, pred=pred)
# offset_hvg_immune = Matrix::colSums(data_g_hvg_immune$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_immune_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_immune[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_immune, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_immune_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_immune_results_list_reml_tmm) <- sapply(nebula_immune_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_immune_results_list_reml_tmm <- lapply(nebula_immune_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_immune_results_list_reml_tmm <- Filter(Negate(is.null), nebula_immune_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_immune_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_immune_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/nebula/immune_attempt_hvg_nebula_res_reml_tmm.rds')
```
###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_immune <- round(GetAssayData(attempt_so_hvg_immune, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_immune)

# meta_hvg_immune <- attempt_so_hvg_immune@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_immune)
# data_g_hvg_immune = group_cell(count=counts_hvg_immune, id=meta_hvg_immune$subject, pred=pred)
# offset_hvg_immune = Matrix::colSums(data_g_hvg_immune$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_immune_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_immune[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_immune, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_immune_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_immune_results_list_reml_pooled) <- sapply(nebula_immune_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_immune_results_list_reml_pooled <- lapply(nebula_immune_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_immune_results_list_reml_pooled <- Filter(Negate(is.null), nebula_immune_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_immune_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_immune_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/nebula/immune_attempt_hvg_nebula_res_reml_pooled.rds')
```

##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_immune, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_immune, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_immune@meta.data$treatment,
                      Subject = attempt_so_hvg_immune@meta.data$subject_id,
                      Visit = attempt_so_hvg_immune@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_immune, ceiling(seq_along(hvgs_immune) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```

```{r echo = F, eval = F}
# Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/1/immune_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/1/immune_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/2/immune_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'Immune/2/immune_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'Immune/3/immune_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'Immune/3/immune_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'Immune/4/immune_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'Immune/4/immune_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual) 

#### Sum expression (pseudo-bulk within individual) 

# PC 

```{r echo = F} 
# PC-1 & PC-2, tPC-IC 
attempt_so$celltype_pc <- ifelse(attempt_so$celltype %in% c("PC-1", "PC-2", "tPC-IC"), 
                                     "PC", as.character(attempt_so$celltype)) 
attempt_so_pc <- subset(attempt_so, celltype_pc == "PC") 
``` 

```{r echo = F}
attempt_so_pc <- FindVariableFeatures(attempt_so_pc, selection.method = "vst", nfeatures = 2000)
hvgs_pc <- VariableFeatures(attempt_so_pc)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_pc <- subset(attempt_so_pc, features = hvgs_pc)
```

#### Proportions 
```{r echo = F, eval = F}
attempt_pc_meta <- attempt_so_hvg_pc@meta.data %>% 
  mutate(visit_treatment = paste0(visit, " ", treatment)) 
attempt_pc_meta$celltype <- factor(attempt_pc_meta$celltype, levels = c("PC-1", "PC-2", "tPC-IC")) 
attempt_pc_meta$visit_treatment <- factor(attempt_pc_meta$visit_treatment, 
                                          levels = c("PRE Placebo", "POST Placebo", 
                                                     "PRE Dapagliflozin", "POST Dapagliflozin")) 
attempt_pc_meta %>% 
  ggplot(aes(visit, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") + 
  theme_classic() + 
  labs(x = NULL, 
       y = "Proportion", 
       fill = "Cell type") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  theme(plot.title = element_text(hjust=0.5, face="bold"), 
        text = element_text(size = 20)) + 
  ggtitle("Proportion of cells") + 
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261")) 
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pc_treatment_visit_proportions_plot.jpeg")

attempt_pc_meta %>% 
  ggplot(aes(treatment, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") + 
  theme_classic() + 
  labs(x = NULL, 
       y = "Proportion", 
       fill = "Cell type") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  theme(plot.title = element_text(hjust=0.5, face="bold"), 
        text = element_text(size = 20)) + 
  ggtitle("Proportion of cells") + 
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261")) 
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pc_treatment_proportions_plot.jpeg")


attempt_pc_meta %>% 
  ggplot(aes(visit_treatment, fill = celltype)) + 
  geom_bar(stat = "count", position = "fill") + 
  theme_classic() + 
  labs(x = NULL, 
       y = "Proportion", 
       fill = "Cell type") + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) + 
  theme(plot.title = element_text(hjust=0.5, face="bold"), 
        text = element_text(size = 20)) + 
  ggtitle("Proportion of cells") + 
  scale_fill_manual(values = c("#264653", "#e9c46a", "#f4a261")) 
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_pc_treatment_visit_proportions_plot.jpeg")
``` 

#### Mixed model (hurdle, nested random effect) 
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_pc <- round(GetAssayData(attempt_so_hvg_pc, layer = "counts")) # load counts and round
# meta_hvg_pc <- attempt_so_hvg_pc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pc)
# data_g_hvg_pc = group_cell(count=counts_hvg_pc, id=meta_hvg_pc$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_pc)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pc_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_pc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, , output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_pc_results_list <- Filter(Negate(is.null), nebula_pc_results_list)  # remove NULLs first
names(nebula_pc_results_list) <- sapply(nebula_pc_results_list, function(x) x$gene)  # set names
nebula_pc_results_list <- lapply(nebula_pc_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pc_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pc_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/nebula/pc_attempt_hvg_nebula_res.rds')
```
###### REML with rounded counts

```{r echo = F, eval = F}
counts_hvg_pc <- round(GetAssayData(attempt_so_hvg_pc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pc)
# REML
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pc_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pc_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pc_results_list_reml) <- sapply(nebula_pc_results_list_reml, function(x) x$gene)  # set names
nebula_pc_results_list_reml <- lapply(nebula_pc_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_pc_results_list_reml <- Filter(Negate(is.null), nebula_pc_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pc_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pc_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/nebula/pc_attempt_hvg_nebula_res_reml.rds')
```

###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_pc <- round(GetAssayData(attempt_so_hvg_pc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pc)

# meta_hvg_pc <- attempt_so_hvg_pc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pc)
# data_g_hvg_pc = group_cell(count=counts_hvg_pc, id=meta_hvg_pc$subject, pred=pred)
# offset_hvg_pc = Matrix::colSums(data_g_hvg_pc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pc_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pc_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pc_results_list_reml_offset) <- sapply(nebula_pc_results_list_reml_offset, function(x) x$gene)  # set names
nebula_pc_results_list_reml_offset <- lapply(nebula_pc_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_pc_results_list_reml_offset <- Filter(Negate(is.null), nebula_pc_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pc_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pc_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/nebula/pc_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_pc <- round(GetAssayData(attempt_so_hvg_pc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pc)

# meta_hvg_pc <- attempt_so_hvg_pc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pc)
# data_g_hvg_pc = group_cell(count=counts_hvg_pc, id=meta_hvg_pc$subject, pred=pred)
# offset_hvg_pc = Matrix::colSums(data_g_hvg_pc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pc_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pc_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pc_results_list_reml_tmm) <- sapply(nebula_pc_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_pc_results_list_reml_tmm <- lapply(nebula_pc_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_pc_results_list_reml_tmm <- Filter(Negate(is.null), nebula_pc_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pc_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pc_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/nebula/pc_attempt_hvg_nebula_res_reml_tmm.rds')
```

###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_pc <- round(GetAssayData(attempt_so_hvg_pc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_pc)

# meta_hvg_pc <- attempt_so_hvg_pc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_pc)
# data_g_hvg_pc = group_cell(count=counts_hvg_pc, id=meta_hvg_pc$subject, pred=pred)
# offset_hvg_pc = Matrix::colSums(data_g_hvg_pc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_pc_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_pc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_pc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_pc_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_pc_results_list_reml_pooled) <- sapply(nebula_pc_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_pc_results_list_reml_pooled <- lapply(nebula_pc_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_pc_results_list_reml_pooled <- Filter(Negate(is.null), nebula_pc_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_pc_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_pc_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/nebula/pc_attempt_hvg_nebula_res_reml_pooled.rds')
```

##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_pc, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_pc, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_pc@meta.data$treatment,
                      Subject = attempt_so_hvg_pc@meta.data$subject_id,
                      Visit = attempt_so_hvg_pc@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```

```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_pc, ceiling(seq_along(hvgs_pc) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```


```{r echo = F, eval = F}
# # Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/1/pc_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/1/pc_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/2/pc_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'PC/2/pc_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# Model 3
# Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PC/3/pc_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PC/3/pc_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PC/4/pc_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'PC/4/pc_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)


# IC

```{r echo = F}
# IC-A, IC-B
attempt_so$celltype_ic <- ifelse(attempt_so$celltype %in% c("IC-A", "IC-B"),
                                     "IC", as.character(attempt_so$celltype))
attempt_so_ic <- subset(attempt_so, celltype_ic == "IC")
```

```{r echo = F}
attempt_so_ic <- FindVariableFeatures(attempt_so_ic, selection.method = "vst", nfeatures = 2000)
hvgs_ic <- VariableFeatures(attempt_so_ic)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_ic <- subset(attempt_so_ic, features = hvgs_ic)
```
#### Proportions
```{r echo = F, eval = F}
attempt_ic_meta <- attempt_so_hvg_ic@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_ic_meta$celltype <- factor(attempt_ic_meta$celltype, levels = c("IC-A", "IC-B"))
attempt_ic_meta$visit_treatment <- factor(attempt_ic_meta$visit_treatment, 
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_ic_meta %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ic_treatment_visit_proportions_plot.jpeg")

attempt_ic_meta %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ic_treatment_proportions_plot.jpeg")

attempt_ic_meta %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ic_treatment_visit_proportions_plot.jpeg")
```

#### Mixed model (hurdle, nested random effect)
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_ic <- round(GetAssayData(attempt_so_hvg_ic, layer = "counts")) # load counts and round
# meta_hvg_ic <- attempt_so_hvg_ic@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ic)
# data_g_hvg_ic = group_cell(count=counts_hvg_ic, id=meta_hvg_ic$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_ic)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ic_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_ic[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ic, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, , output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_ic_results_list <- Filter(Negate(is.null), nebula_ic_results_list)  # remove NULLs first
names(nebula_ic_results_list) <- sapply(nebula_ic_results_list, function(x) x$gene)  # set names
nebula_ic_results_list <- lapply(nebula_ic_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ic_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ic_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/nebula/ic_attempt_hvg_nebula_res.rds')
```
###### REML with rounded counts

```{r echo = F, eval = F}
counts_hvg_ic <- round(GetAssayData(attempt_so_hvg_ic, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ic)

# REML
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ic_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ic[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ic, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ic_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ic_results_list_reml) <- sapply(nebula_ic_results_list_reml, function(x) x$gene)  # set names
nebula_ic_results_list_reml <- lapply(nebula_ic_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_ic_results_list_reml <- Filter(Negate(is.null), nebula_ic_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ic_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ic_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/nebula/ic_attempt_hvg_nebula_res_reml.rds')
```

###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_ic <- round(GetAssayData(attempt_so_hvg_ic, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ic)

# meta_hvg_ic <- attempt_so_hvg_ic@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ic)
# data_g_hvg_ic = group_cell(count=counts_hvg_ic, id=meta_hvg_ic$subject, pred=pred)
# offset_hvg_ic = Matrix::colSums(data_g_hvg_ic$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ic_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ic[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ic, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ic_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ic_results_list_reml_offset) <- sapply(nebula_ic_results_list_reml_offset, function(x) x$gene)  # set names
nebula_ic_results_list_reml_offset <- lapply(nebula_ic_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_ic_results_list_reml_offset <- Filter(Negate(is.null), nebula_ic_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ic_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ic_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/nebula/ic_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_ic <- round(GetAssayData(attempt_so_hvg_ic, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ic)

# meta_hvg_ic <- attempt_so_hvg_ic@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ic)
# data_g_hvg_ic = group_cell(count=counts_hvg_ic, id=meta_hvg_ic$subject, pred=pred)
# offset_hvg_ic = Matrix::colSums(data_g_hvg_ic$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ic_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ic[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ic, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ic_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ic_results_list_reml_tmm) <- sapply(nebula_ic_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_ic_results_list_reml_tmm <- lapply(nebula_ic_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_ic_results_list_reml_tmm <- Filter(Negate(is.null), nebula_ic_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ic_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ic_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/nebula/ic_attempt_hvg_nebula_res_reml_tmm.rds')
```
###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_ic <- round(GetAssayData(attempt_so_hvg_ic, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ic)

# meta_hvg_ic <- attempt_so_hvg_ic@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ic)
# data_g_hvg_ic = group_cell(count=counts_hvg_ic, id=meta_hvg_ic$subject, pred=pred)
# offset_hvg_ic = Matrix::colSums(data_g_hvg_ic$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ic_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ic[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ic, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ic_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ic_results_list_reml_pooled) <- sapply(nebula_ic_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_ic_results_list_reml_pooled <- lapply(nebula_ic_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_ic_results_list_reml_pooled <- Filter(Negate(is.null), nebula_ic_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ic_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ic_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/nebula/ic_attempt_hvg_nebula_res_reml_pooled.rds')
```
##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_ic, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_ic, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_ic@meta.data$treatment,
                      Subject = attempt_so_hvg_ic@meta.data$subject_id,
                      Visit = attempt_so_hvg_ic@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_ic, ceiling(seq_along(hvgs_ic) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```


```{r echo = F, eval = F}
# Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/1/ic_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/1/ic_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/2/ic_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'IC/2/ic_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'IC/3/ic_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'IC/3/ic_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'IC/4/ic_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'IC/4/ic_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)

# EC

```{r echo = F}
attempt_so$celltype_ec <- ifelse(attempt_so$celltype %in% c("EC-PTC", "EC-GC", "EC-AEA", "EC-LYM"),
                                     "EC", as.character(attempt_so$celltype))
attempt_so_ec <- subset(attempt_so, celltype_ec == "EC")
```

```{r echo = F}
attempt_so_ec <- FindVariableFeatures(attempt_so_ec, selection.method = "vst", nfeatures = 2000)
hvgs_ec <- VariableFeatures(attempt_so_ec)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_ec <- subset(attempt_so_ec, features = hvgs_ec)
```

#### Proportions
```{r echo = F, eval = F}
attempt_ec_meta <- attempt_so_hvg_ec@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_ec_meta$celltype <- factor(attempt_ec_meta$celltype, levels = c("EC-PTC", "EC-GC", "EC-AEA", "EC-LYM"))
attempt_ec_meta$visit_treatment <- factor(attempt_ec_meta$visit_treatment, 
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_ec_meta %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ec_treatment_visit_proportions_plot.jpeg")

attempt_ec_meta %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ec_treatment_proportions_plot.jpeg")

attempt_ec_meta %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f", "#e9c46a", "#f4a261"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_ec_treatment_visit_proportions_plot.jpeg")
```

#### Mixed model (hurdle, nested random effect)
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_ec <- round(GetAssayData(attempt_so_hvg_ec, layer = "counts")) # load counts and round
# meta_hvg_ec <- attempt_so_hvg_ec@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ec)
# data_g_hvg_ec = group_cell(count=counts_hvg_ec, id=meta_hvg_ec$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_ec)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ec_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_ec[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ec, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, , output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_ec_results_list <- Filter(Negate(is.null), nebula_ec_results_list)  # remove NULLs first
names(nebula_ec_results_list) <- sapply(nebula_ec_results_list, function(x) x$gene)  # set names
nebula_ec_results_list <- lapply(nebula_ec_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ec_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ec_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/nebula/ec_attempt_hvg_nebula_res.rds')
```
###### REML with rounded counts

```{r echo = F, eval = F}
counts_hvg_ec <- round(GetAssayData(attempt_so_hvg_ec, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ec)

# REML
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ec_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ec[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ec, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ec_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ec_results_list_reml) <- sapply(nebula_ec_results_list_reml, function(x) x$gene)  # set names
nebula_ec_results_list_reml <- lapply(nebula_ec_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_ec_results_list_reml <- Filter(Negate(is.null), nebula_ec_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ec_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ec_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/nebula/ec_attempt_hvg_nebula_res_reml.rds')
```

###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_ec <- round(GetAssayData(attempt_so_hvg_ec, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ec)

# meta_hvg_ec <- attempt_so_hvg_ec@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ec)
# data_g_hvg_ec = group_cell(count=counts_hvg_ec, id=meta_hvg_ec$subject, pred=pred)
# offset_hvg_ec = Matrix::colSums(data_g_hvg_ec$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ec_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ec[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ec, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ec_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ec_results_list_reml_offset) <- sapply(nebula_ec_results_list_reml_offset, function(x) x$gene)  # set names
nebula_ec_results_list_reml_offset <- lapply(nebula_ec_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_ec_results_list_reml_offset <- Filter(Negate(is.null), nebula_ec_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ec_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ec_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/nebula/ec_attempt_hvg_nebula_res_reml_offset.rds')
```

###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_ec <- round(GetAssayData(attempt_so_hvg_ec, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ec)

# meta_hvg_ec <- attempt_so_hvg_ec@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ec)
# data_g_hvg_ec = group_cell(count=counts_hvg_ec, id=meta_hvg_ec$subject, pred=pred)
# offset_hvg_ec = Matrix::colSums(data_g_hvg_ec$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ec_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ec[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ec, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ec_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ec_results_list_reml_tmm) <- sapply(nebula_ec_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_ec_results_list_reml_tmm <- lapply(nebula_ec_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_ec_results_list_reml_tmm <- Filter(Negate(is.null), nebula_ec_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ec_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ec_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/nebula/ec_attempt_hvg_nebula_res_reml_tmm.rds')
```
###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_ec <- round(GetAssayData(attempt_so_hvg_ec, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_ec)

# meta_hvg_ec <- attempt_so_hvg_ec@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_ec)
# data_g_hvg_ec = group_cell(count=counts_hvg_ec, id=meta_hvg_ec$subject, pred=pred)
# offset_hvg_ec = Matrix::colSums(data_g_hvg_ec$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_ec_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_ec[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_ec, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_ec_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_ec_results_list_reml_pooled) <- sapply(nebula_ec_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_ec_results_list_reml_pooled <- lapply(nebula_ec_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_ec_results_list_reml_pooled <- Filter(Negate(is.null), nebula_ec_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_ec_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_ec_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/nebula/ec_attempt_hvg_nebula_res_reml_pooled.rds')
```

##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_ec, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_ec, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_ec@meta.data$treatment,
                      Subject = attempt_so_hvg_ec@meta.data$subject_id,
                      Visit = attempt_so_hvg_ec@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_ec, ceiling(seq_along(hvgs_ec) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```


```{r echo = F, eval = F}
# Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/1/ec_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/1/ec_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/2/ec_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'EC/2/ec_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'EC/3/ec_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'EC/3/ec_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'EC/4/ec_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'EC/4/ec_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)

# FIB, VSMC/P

```{r echo = F}
attempt_so$celltype_fibvsmc <- ifelse(attempt_so$celltype %in% c("FIB", "VSMC/P"),
                                     "FIBVSMC", as.character(attempt_so$celltype))
attempt_so_fibvsmc <- subset(attempt_so, celltype_fibvsmc == "FIBVSMC")
```

```{r echo = F}
attempt_so_fibvsmc <- FindVariableFeatures(attempt_so_fibvsmc, selection.method = "vst", nfeatures = 2000)
hvgs_fibvsmc <- VariableFeatures(attempt_so_fibvsmc)

# Perform remaining steps on top 2000 hvgs
# Subset Seurat object to only HVGs
attempt_so_hvg_fibvsmc <- subset(attempt_so_fibvsmc, features = hvgs_fibvsmc)
```

#### Proportions
```{r echo = F, eval = F}
attempt_fibvsmc_meta <- attempt_so_hvg_fibvsmc@meta.data %>%
  mutate(visit_treatment = paste0(visit, " ", treatment))
attempt_fibvsmc_meta$celltype <- factor(attempt_fibvsmc_meta$celltype, levels = c("FIB", "VSMC/P"))
attempt_fibvsmc_meta$visit_treatment <- factor(attempt_fibvsmc_meta$visit_treatment, 
                                          levels = c("PRE Placebo", "POST Placebo",
                                                     "PRE Dapagliflozin", "POST Dapagliflozin"))
attempt_fibvsmc_meta %>%
  ggplot(aes(visit, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_fibvsmc_treatment_visit_proportions_plot.jpeg")

attempt_fibvsmc_meta %>%
  ggplot(aes(treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_fibvsmc_treatment_proportions_plot.jpeg")

attempt_fibvsmc_meta %>%
  ggplot(aes(visit_treatment, fill = celltype)) +
  geom_bar(stat = "count", position = "fill") +
  theme_classic() +
  labs(x = NULL,
       y = "Proportion",
       fill = "Cell type") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +
  theme(plot.title = element_text(hjust=0.5, face="bold"),
        text = element_text(size = 20)) +
  ggtitle("Proportion of cells") +
  scale_fill_manual(values = c("#264653", "#2a9d8f"))
temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, height = 10, width = 8)
s3$upload_file(temp_file, "attempt", "Figures/Proportions/attempt_fibvsmc_treatment_visit_proportions_plot.jpeg")
```

#### Mixed model (hurdle, nested random effect)
##### nebula
###### ML with rounded counts

```{r echo = F, eval = F}
counts_hvg_fibvsmc <- round(GetAssayData(attempt_so_hvg_fibvsmc, layer = "counts")) # load counts and round
# meta_hvg_fibvsmc <- attempt_so_hvg_fibvsmc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_fibvsmc)
# data_g_hvg_fibvsmc = group_cell(count=counts_hvg_fibvsmc, id=meta_hvg_fibvsmc$subject, pred=pred)

# With parallelization
# List of genes
genes_list <- rownames(counts_hvg_fibvsmc)

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_fibvsmc_results_list <- foreach(g = genes_list, .packages = c("nebula", "Matrix")) %dopar% {
  tryCatch({
    count_gene <- counts_hvg_fibvsmc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_fibvsmc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    result <- nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred, , output_re = T, covariance = T)
    list(gene = g, result = result)  # return both gene name and result
    
  }, error = function(e) {
    NULL
  })
}
# set the names of results based on gene names
nebula_fibvsmc_results_list <- Filter(Negate(is.null), nebula_fibvsmc_results_list)  # remove NULLs first
names(nebula_fibvsmc_results_list) <- sapply(nebula_fibvsmc_results_list, function(x) x$gene)  # set names
nebula_fibvsmc_results_list <- lapply(nebula_fibvsmc_results_list, function(x) x$result)  # clean list back to just results


end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_fibvsmc_results_list))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_fibvsmc_results_list, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/nebula/fibvsmc_attempt_hvg_nebula_res.rds')
```
###### REML with rounded counts

```{r echo = F, eval = F}
counts_hvg_fibvsmc <- round(GetAssayData(attempt_so_hvg_fibvsmc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_fibvsmc)

# REML
cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_fibvsmc_results_list_reml <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_fibvsmc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_fibvsmc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM")
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_fibvsmc_results_list_reml) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_fibvsmc_results_list_reml) <- sapply(nebula_fibvsmc_results_list_reml, function(x) x$gene)  # set names
nebula_fibvsmc_results_list_reml <- lapply(nebula_fibvsmc_results_list_reml, function(x) x$result)  # clean list back to just results
nebula_fibvsmc_results_list_reml <- Filter(Negate(is.null), nebula_fibvsmc_results_list_reml)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_fibvsmc_results_list_reml))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_fibvsmc_results_list_reml, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/nebula/fibvsmc_attempt_hvg_nebula_res_reml.rds')
```
###### REML with rounded counts & offset

```{r echo = F, eval = F}
counts_hvg_fibvsmc <- round(GetAssayData(attempt_so_hvg_fibvsmc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_fibvsmc)

# meta_hvg_fibvsmc <- attempt_so_hvg_fibvsmc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_fibvsmc)
# data_g_hvg_fibvsmc = group_cell(count=counts_hvg_fibvsmc, id=meta_hvg_fibvsmc$subject, pred=pred)
# offset_hvg_fibvsmc = Matrix::colSums(data_g_hvg_fibvsmc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_fibvsmc_results_list_reml_offset <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_fibvsmc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_fibvsmc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$library_size)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_fibvsmc_results_list_reml_offset) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_fibvsmc_results_list_reml_offset) <- sapply(nebula_fibvsmc_results_list_reml_offset, function(x) x$gene)  # set names
nebula_fibvsmc_results_list_reml_offset <- lapply(nebula_fibvsmc_results_list_reml_offset, function(x) x$result)  # clean list back to just results
nebula_fibvsmc_results_list_reml_offset <- Filter(Negate(is.null), nebula_fibvsmc_results_list_reml_offset)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_fibvsmc_results_list_reml_offset))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_fibvsmc_results_list_reml_offset, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/nebula/fibvsmc_attempt_hvg_nebula_res_reml_offset.rds')
```
###### REML with rounded counts & TMM offset

```{r echo = F, eval = F}
counts_hvg_fibvsmc <- round(GetAssayData(attempt_so_hvg_fibvsmc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_fibvsmc)

# meta_hvg_fibvsmc <- attempt_so_hvg_fibvsmc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_fibvsmc)
# data_g_hvg_fibvsmc = group_cell(count=counts_hvg_fibvsmc, id=meta_hvg_fibvsmc$subject, pred=pred)
# offset_hvg_fibvsmc = Matrix::colSums(data_g_hvg_fibvsmc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_fibvsmc_results_list_reml_tmm <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_fibvsmc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_fibvsmc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$tmm_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_fibvsmc_results_list_reml_tmm) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_fibvsmc_results_list_reml_tmm) <- sapply(nebula_fibvsmc_results_list_reml_tmm, function(x) x$gene)  # set names
nebula_fibvsmc_results_list_reml_tmm <- lapply(nebula_fibvsmc_results_list_reml_tmm, function(x) x$result)  # clean list back to just results
nebula_fibvsmc_results_list_reml_tmm <- Filter(Negate(is.null), nebula_fibvsmc_results_list_reml_tmm)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_fibvsmc_results_list_reml_tmm))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_fibvsmc_results_list_reml_tmm, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/nebula/fibvsmc_attempt_hvg_nebula_res_reml_tmm.rds')
```
###### REML with rounded counts & pooled offset

```{r echo = F}
counts_hvg_fibvsmc <- round(GetAssayData(attempt_so_hvg_fibvsmc, layer = "counts")) # load counts and round
genes_list <- rownames(counts_hvg_fibvsmc)

# meta_hvg_fibvsmc <- attempt_so_hvg_fibvsmc@meta.data
# pred = model.matrix(~treatment*visit, data = meta_hvg_fibvsmc)
# data_g_hvg_fibvsmc = group_cell(count=counts_hvg_fibvsmc, id=meta_hvg_fibvsmc$subject, pred=pred)
# offset_hvg_fibvsmc = Matrix::colSums(data_g_hvg_fibvsmc$count) 

cl <- makeCluster(100)
registerDoParallel(cl)

start_time <- Sys.time()

nebula_fibvsmc_results_list_reml_pooled <- foreach(g = genes_list, .packages = c("nebula", "Matrix"),
                                       .errorhandling = "pass") %dopar% {
  warn <- NULL
  err <- NULL
  res <- NULL
  
  tryCatch({
    count_gene <- counts_hvg_fibvsmc[g, , drop = FALSE]
    meta_gene <- subset(attempt_so_hvg_fibvsmc, features = g)@meta.data
    pred_gene <- model.matrix(~treatment * visit, data = meta_gene)
    data_g_gene <- group_cell(count = count_gene, id = meta_gene$subject, pred = pred_gene)

    res <- withCallingHandlers({
      nebula(count = data_g_gene$count, id = data_g_gene$id, pred = data_g_gene$pred,
             ncore = 1, output_re = TRUE, covariance = TRUE, reml = 1, model = "NBLMM", 
             offset = meta_gene$pooled_offset)
    }, warning = function(w) {
      warn <<- conditionMessage(w)
      invokeRestart("muffleWarning")
    })

  }, error = function(e) {
    err <<- conditionMessage(e)
  })

  list(gene = g, result = res, warning = warn, error = err)
}

## After the loop:
for (res in nebula_fibvsmc_results_list_reml_pooled) {
  if (!is.null(res$warning)) cat(sprintf("Warning for gene %s: %s\n", res$gene, res$warning))
  if (!is.null(res$error)) cat(sprintf("Error for gene %s: %s\n", res$gene, res$error))
}


# set the names of results based on gene names
names(nebula_fibvsmc_results_list_reml_pooled) <- sapply(nebula_fibvsmc_results_list_reml_pooled, function(x) x$gene)  # set names
nebula_fibvsmc_results_list_reml_pooled <- lapply(nebula_fibvsmc_results_list_reml_pooled, function(x) x$result)  # clean list back to just results
nebula_fibvsmc_results_list_reml_pooled <- Filter(Negate(is.null), nebula_fibvsmc_results_list_reml_pooled)  # remove NULLs first

end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)

nebula_nonconverged_percent <- (length(genes_list)-length(nebula_fibvsmc_results_list_reml_pooled))/length(genes_list)
print(paste0(nebula_nonconverged_percent*100, "% filtered due to low expression"))
temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(nebula_fibvsmc_results_list_reml_pooled, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/nebula/fibvsmc_attempt_hvg_nebula_res_reml_pooled.rds')
```

##### glmmTMB

```{r echo = F, eval = F}
# Subset Seurat object to retain only these genes
# expr_matrix <- as.matrix(GetAssayData(attempt_so_hvg_fibvsmc, layer = "data"))
expr_matrix <- round(as.matrix(GetAssayData(attempt_so_hvg_fibvsmc, layer = "count"))) # round soupX corrected non-integer count data to integers
expr_df <- as.data.frame(as.table(as.matrix(expr_matrix)))
colnames(expr_df) <- c("Gene", "Cell", "Count")

sc_data <- data.frame(Gene = expr_df$Gene,
                      Cell = expr_df$Cell,
                      Treatment = attempt_so_hvg_fibvsmc@meta.data$treatment,
                      Subject = attempt_so_hvg_fibvsmc@meta.data$subject_id,
                      Visit = attempt_so_hvg_fibvsmc@meta.data$visit,
                      Count = as.vector(expr_df$Count))
```


```{r echo = F, eval = F}
# set up batches (of 1000)
genes_list <- list()
batch_size <- 1000
genes_list <- split(hvgs_fibvsmc, ceiling(seq_along(hvgs_fibvsmc) / batch_size))
names(genes_list) <- paste0("genes_", 1:2)
list2env(genes_list, envir = .GlobalEnv)

sc_data_list <- list()
for (i in 1:2) {
  sc_data_list[[i]] <- subset(sc_data, Gene %in% get(paste0("genes_", i)))
}
names(sc_data_list) <- paste0("sc_data_", 1:2)
list2env(sc_data_list, envir = .GlobalEnv)
remove(sc_data_list)
```

```{r echo = F, eval = F}
cl <- parallel::makeCluster(100)

# Model 1
registerDoParallel(cl)
results_list <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)


# Model 2
registerDoParallel(cl)
results_list_2 <- list()
start_time <- Sys.time()
for (i in seq_along(genes_list)) {
  results_list_2[[i]] <- foreach(g = genes_list[[i]], .packages = c("emmeans", "glmmTMB", "data.table")) %dopar% {
    fit_model_2(g, sc_dat = sc_data)
  }
}
end_time <- Sys.time()
print(end_time - start_time)
stopCluster(cl)
```


```{r echo = F, eval = F}
# Model 1
# Combine all model data tables into one
model_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined <- rbindlist(model_df_list, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list <- lapply(results_list, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined <- rbindlist(emmeans_df_list, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/1/fibvsmcp_attempt_scrna_mm_model_combined_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/1/fibvsmcp_attempt_scrna_mm_emmeans_combined_counts.rds')

# Model 2
# Combine all model data tables into one
model_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
model_df_combined_2 <- rbindlist(model_df_list_2, fill = TRUE)

# Combine all emmeans data tables into one
emmeans_df_list_2 <- lapply(results_list_2, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
emmeans_df_combined_2 <- rbindlist(emmeans_df_list_2, fill = TRUE)

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(model_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/2/fibvsmcp_attempt_scrna_mm_model_combined_2_counts.rds')

temp_file <- tempfile(fileext = "rds") # need to create a temporary file
saveRDS(emmeans_df_combined_2, temp_file) # save the temp file locally (will delete after R session)
s3$upload_file(temp_file, "attempt", 'FIBVSMCP/2/fibvsmcp_attempt_scrna_mm_emmeans_combined_2_counts.rds')

# # Model 3
# # Combine all model data tables into one
# model_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_3 <- rbindlist(model_df_list_3, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_3 <- lapply(results_list_3, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_3 <- rbindlist(emmeans_df_list_3, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'FIBVSMCP/3/fibvsmcp_attempt_scrna_mm_model_combined_3_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_3, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'FIBVSMCP/3/fibvsmcp_attempt_scrna_mm_emmeans_combined_3_counts.rds')

# # Model 4
# # Combine all model data tables into one
# model_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$model), fill = TRUE))
# model_df_combined_4 <- rbindlist(model_df_list_4, fill = TRUE)
# 
# # Combine all emmeans data tables into one
# emmeans_df_list_4 <- lapply(results_list_4, function(x) rbindlist(lapply(x, function(y) y$emmeans), fill = TRUE))
# emmeans_df_combined_4 <- rbindlist(emmeans_df_list_4, fill = TRUE)
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(model_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'FIBVSMCP/4/fibvsmcp_attempt_scrna_mm_model_combined_4_counts.rds')
# 
# temp_file <- tempfile(fileext = "rds") # need to create a temporary file
# saveRDS(emmeans_df_combined_4, temp_file) # save the temp file locally (will delete after R session)
# s3$upload_file(temp_file, "attempt", 'FIBVSMCP/4/fibvsmcp_attempt_scrna_mm_emmeans_combined_4_counts.rds')
```

#### Average expression (pseudo-bulk within individual)

#### Sum expression (pseudo-bulk within individual)

# Expression

```{r echo = F}
prefixes <- c("pt", "tal", "pc", "ic", "ec", "fibvsmcp", "immune")
mods <- paste0("mod", 1:4)

nonconverged_genes <- setNames(lapply(prefixes, function(prefix) {
  setNames(lapply(mods, function(mod) {
    s3_key <- paste0("Nonconverged genes/", prefix, "_nonconverged_genes_", mod, ".rds")
    temp_file <- tempfile(fileext = ".rds")
    s3$download_file("attempt", s3_key, temp_file)
    readRDS(temp_file)
  }), mods)
}), prefixes)
```

### PT
```{r echo = F}
percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_pt, features = nonconverged_genes$pt[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_pt, features = nonconverged_genes$pt[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_pt, features = nonconverged_genes$pt[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_pt, features = nonconverged_genes$pt[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
pt_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

pt_nonconverged_summary <- pt_nonconverged_summary[, c(ncol(pt_nonconverged_summary), 1:(ncol(pt_nonconverged_summary)-1))]
colnames(pt_nonconverged_summary) <- gsub("\\.", "", colnames(pt_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(pt_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/pt_nonconverged_summary.rds')


pt_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(pt_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in PT cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/pt_nonconverged_expression_plot.jpeg") 
```

### TAL
```{r echo = F}
percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_tal, features = nonconverged_genes$tal[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_tal, features = nonconverged_genes$tal[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_tal, features = nonconverged_genes$tal[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_tal, features = nonconverged_genes$tal[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
tal_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

tal_nonconverged_summary <- tal_nonconverged_summary[, c(ncol(tal_nonconverged_summary), 1:(ncol(tal_nonconverged_summary)-1))]
colnames(tal_nonconverged_summary) <- gsub("\\.", "", colnames(tal_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(tal_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/tal_nonconverged_summary.rds')


tal_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(tal_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in TAL cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/tal_nonconverged_expression_plot.jpeg") 
```
### immune
```{r echo = F}
percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_immune, features = nonconverged_genes$immune[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_immune, features = nonconverged_genes$immune[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_immune, features = nonconverged_genes$immune[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_immune, features = nonconverged_genes$immune[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
immune_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

immune_nonconverged_summary <- immune_nonconverged_summary[, c(ncol(immune_nonconverged_summary), 1:(ncol(immune_nonconverged_summary)-1))]
colnames(immune_nonconverged_summary) <- gsub("\\.", "", colnames(immune_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(immune_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/immune_nonconverged_summary.rds')


immune_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(immune_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in Immune cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/immune_nonconverged_expression_plot.jpeg") 
```
### PC
```{r echo = F}
attempt_so_hvg_pc[["percent.nonconverged.mod1"]] <- PercentageFeatureSet(attempt_so_hvg_pc, features = nonconverged_genes$pc[[1]])

percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_pc, features = nonconverged_genes$pc[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_pc, features = nonconverged_genes$pc[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_pc, features = nonconverged_genes$pc[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_pc, features = nonconverged_genes$pc[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
pc_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

pc_nonconverged_summary <- pc_nonconverged_summary[, c(ncol(pc_nonconverged_summary), 1:(ncol(pc_nonconverged_summary)-1))]
colnames(pc_nonconverged_summary) <- gsub("\\.", "", colnames(pc_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(pc_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/pc_nonconverged_summary.rds')


pc_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(pc_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in PC cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/pc_nonconverged_expression_plot.jpeg") 
```

### IC
```{r echo = F}
attempt_so_hvg_ic[["percent.nonconverged.mod1"]] <- PercentageFeatureSet(attempt_so_hvg_ic, features = nonconverged_genes$ic[[1]])

percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_ic, features = nonconverged_genes$ic[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_ic, features = nonconverged_genes$ic[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_ic, features = nonconverged_genes$ic[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_ic, features = nonconverged_genes$ic[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
ic_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

ic_nonconverged_summary <- ic_nonconverged_summary[, c(ncol(ic_nonconverged_summary), 1:(ncol(ic_nonconverged_summary)-1))]
colnames(ic_nonconverged_summary) <- gsub("\\.", "", colnames(ic_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(ic_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/ic_nonconverged_summary.rds')


ic_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(ic_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in IC cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/ic_nonconverged_expression_plot.jpeg") 
```
### EC
```{r echo = F}
attempt_so_hvg_ec[["percent.nonconverged.mod1"]] <- PercentageFeatureSet(attempt_so_hvg_ec, features = nonconverged_genes$ec[[1]])

percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_ec, features = nonconverged_genes$ec[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_ec, features = nonconverged_genes$ec[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_ec, features = nonconverged_genes$ec[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_ec, features = nonconverged_genes$ec[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
ec_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

ec_nonconverged_summary <- ec_nonconverged_summary[, c(ncol(ec_nonconverged_summary), 1:(ncol(ec_nonconverged_summary)-1))]
colnames(ec_nonconverged_summary) <- gsub("\\.", "", colnames(ec_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(ec_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/ec_nonconverged_summary.rds')


ec_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(ec_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in EC cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/ec_nonconverged_expression_plot.jpeg") 
```
### FIB, VSMC/P
```{r echo = F}
attempt_so_hvg_fibvsmc[["percent.nonconverged.mod1"]] <- PercentageFeatureSet(attempt_so_hvg_fibvsmc, features = nonconverged_genes$fibvsmcp[[1]])

percent.nonconverged.mod1 <- PercentageFeatureSet(attempt_so_hvg_fibvsmc, features = nonconverged_genes$fibvsmcp[["mod1"]])
percent.nonconverged.mod2 <- PercentageFeatureSet(attempt_so_hvg_fibvsmc, features = nonconverged_genes$fibvsmcp[["mod2"]])
percent.nonconverged.mod3 <- PercentageFeatureSet(attempt_so_hvg_fibvsmc, features = nonconverged_genes$fibvsmcp[["mod3"]])
percent.nonconverged.mod4 <- PercentageFeatureSet(attempt_so_hvg_fibvsmc, features = nonconverged_genes$fibvsmcp[["mod4"]])

summary_list <- list(
  "Model 1" = summary(percent.nonconverged.mod1),
  "Model 2" = summary(percent.nonconverged.mod2),
  "Model 3" = summary(percent.nonconverged.mod3),
  "Model 4" = summary(percent.nonconverged.mod4)
)

# Convert each summary vector to a one-row data frame
fibvsmcp_nonconverged_summary <- do.call(rbind, lapply(names(summary_list), function(model_name) {
  stats <- summary_list[[model_name]]
  # Coerce named vector to data.frame (one row)
  df <- as.data.frame(as.list(stats))
  df$Model <- model_name
  return(df)
}))

fibvsmcp_nonconverged_summary <- fibvsmcp_nonconverged_summary[, c(ncol(fibvsmcp_nonconverged_summary), 1:(ncol(fibvsmcp_nonconverged_summary)-1))]
colnames(fibvsmcp_nonconverged_summary) <- gsub("\\.", "", colnames(fibvsmcp_nonconverged_summary))
temp_file <- tempfile(fileext = "rds")
saveRDS(fibvsmcp_nonconverged_summary, temp_file)
s3$upload_file(temp_file, "attempt", 'Nonconverged genes/fibvsmcp_nonconverged_summary.rds')


fibvsmcp_nonconverged_df <- rbind(data.frame(expression = percent.nonconverged.mod1, model = "Model 1"), 
                            data.frame(expression = percent.nonconverged.mod2, model = "Model 2"), 
                            data.frame(expression = percent.nonconverged.mod3, model = "Model 3"), 
                            data.frame(expression = percent.nonconverged.mod4, model = "Model 4"))

ggplot(fibvsmcp_nonconverged_df, aes(x = model, y = expression, color = model)) +
  geom_hline(yintercept = 5, linetype = "dashed", color = "#fca311") +
  geom_jitter(alpha = 0.1, shape = 21, stroke = 0, size = 5, aes(fill = model)) + 
  geom_boxplot(outliers = F, width = 0.6, linewidth = 1.25, aes(fill = model)) +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        text = element_text(size = 15)) +
  labs(x = "Model", y = "% Expression",
       title = "% Expression of nonconverged genes in FIB, VSMC/P cells") +
  guides(color = "none",
         fill = "none") +
  scale_color_manual(values = c("#588157", "#55828b", 
                                "#f79d65", "#e26d5c")) +
  scale_fill_manual(values = c("#7BA179", "#76A0A9", 
                                "#FAB889", "#EB8B7E"))

temp_file <- tempfile(fileext = ".jpeg")
ggsave(temp_file, width = 10)
s3$upload_file(temp_file, "attempt", "Figures/nonconverged/fibvsmcp_nonconverged_expression_plot.jpeg") 
```

# HVGs (union)
```{r echo = F}
hvgs_union <- unique(c(hvgs_ec, hvgs_fibvsmc, hvgs_ic, hvgs_immune, hvgs_pc, hvgs_pt, hvgs_tal))
length(hvgs_union)
```
